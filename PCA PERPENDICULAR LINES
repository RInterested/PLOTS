
#goes with file pca_example.csv in Drive
#goes with file pca_example.csv in Drive

dat<-read.csv(file.choose())
head(dat)
colnames(dat)[7] <- "lattice"
colnames(dat)[2] <- "atomic.no"
dat1 <- subset(dat[1:15,1:3])
row.names(dat1) <- dat1$compounds
dat1 <- dat1[,-1]
head(dat1)

scaled_dat <- as.data.frame(scale(dat1,center=T)) 
head(scaled_dat)
X <- as.matrix(scaled_dat) 
head(X)


(scaled_dat[1,1] - mean(scaled_dat[,1]))/sd(scaled_dat[,1]) # Confirming what scaling did.

C <- cov(X) # Covariance matrix
C

lambda <- eigen(C)$values # Eigenvalues
lambda_matrix <- diag(2)*eigen(C)$values # Eigenvalues matrix
lambda_matrix


e_vectors <- eigen(C)$vectors # Eigenvectors matrix (2 x 2)
e_vectors



score_matrix <-  X %*% lambda_matrix %*% e_vectors # Score matrix = (15 x 2) %*% (2 x 2) = (15 x 2)
colnames(score_matrix) <-c("V1","V2")
head(score_matrix)


#relative influence of eigenvalues, for instance PC1:

eigen(C)$values[1]/sum(eigen(C)$values) * 100



#Plot of two columns:

plot(melting.point ~ atomic.no, col = as.factor(rownames(scaled_dat)), pch = 19, data = scaled_dat)
abline(v=0,h=0, col = "dark gray")

#Overlap pertinent evectors


abline(0, e_vectors[1,2]/e_vectors[1,1],col='red')
abline(0, e_vectors[2,1]/e_vectors[2,2],col='light blue')

arrows(x0 = 0, y0 = 0, x1 = lambda[1]*e_vectors[1,1], y1 = lambda[1]*e_vectors[1,2],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = lambda[2]*e_vectors[2,1], y1 = lambda[2]*e_vectors[2,2],col="blue", lwd=2)

with(scaled_dat,text(melting.point ~ atomic.no, labels = as.factor(rownames(scaled_dat)), pos=3))
#Plot the lines from first evector to points

line1 <- c(0, e_vectors[1,2]/e_vectors[1,1])

perp.segment.coord <- function(x0, y0, line1){
  
  #finds endpoint for a perpendicular segment from the point (x0,y0) to the line1
  
  a <- line1[1]  #intercept
  b <- line1[2]  #slope
  
  x1 <- (x0 + b * y0 - a * b)/(1 + b^2)
  y1 <- a + b * x1
  list(x0=x0, y0=y0, x1=x1, y1=y1)
}

ss <- perp.segment.coord(scaled_dat$atomic.no, scaled_dat$melting.point, line1)
# do.call(segments, ss)
# which is the same as:
segments(x0 = ss$x0, x1 = ss$x1, y0 = ss$y0, y1 = ss$y1, col='red')


plot(melting.point ~ atomic.no, col = as.factor(rownames(scaled_dat)), pch = 19, data = scaled_dat)

abline(v=0,h=0, col = "dark gray")

#Overlap pertinent evectors



abline(0, e_vectors[1,2]/e_vectors[1,1],col='red')
abline(0, e_vectors[2,1]/e_vectors[2,2],col='light blue',lwd=2)

arrows(x0 = 0, y0 = 0, x1 = lambda[1]*e_vectors[1,1], y1 = lambda[1]*e_vectors[1,2],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = lambda[2]*e_vectors[2,1], y1 = lambda[2]*e_vectors[2,2],col="blue", lwd=2)


line1a <- c(0, e_vectors[2,2]/e_vectors[2,1])
ssa <- perp.segment.coord(scaled_dat$atomic.no, scaled_dat$melting.point, line1a)
# do.call(segments, ss)
# which is the same as:
segments(x0 = ssa$x0, x1 = ssa$x1, y0 = ssa$y0, y1 = ssa$y1, lwd= 2, col='light blue')

with(scaled_dat,text(melting.point ~ atomic.no, labels = as.factor(rownames(scaled_dat)), pos=3))

#Now compare side-by-side with plotted first and second column Scores

score <- as.data.frame(score_matrix)

plot(V2 ~ V1, col=as.factor(rownames(score)), pch = 19, xlab='V1', ylab='V2',data=score)

abline(v=0, col = 'red')
abline(h=0, col='light blue',lwd=2)


perp.segment.horiz <- function(x0, y0){
  
  #finds endpoint for a perpendicular segment from the point (x0,y0) to the horizontal
  x1 <- 0
  y1 <- y0
  list(x0=x0, y0=y0, x1=x1, y1=y1)
}

ss1 <- perp.segment.horiz(score[,1], score[,2])
segments(x0 = ss1$x0, x1 = ss1$x1, y0 = ss1$y0, y1 = ss1$y1, col='red')

with(score,text(V2 ~ V1, labels=as.factor(rownames(score)), pos = 3))


plot(V2 ~ V1, col=as.factor(rownames(score)), pch = 19, xlab='V1', ylab='V2',data=score)

abline(v=0, col = 'red')
abline(h=0, col='light blue',lwd=2)


perp.segment.vert <- function(x0, y0){
  
  #finds endpoint for a perpendicular segment from the point (x0,y0) to the horizontal
  x1 <- x0
  y1 <- 0
  list(x0=x0, y0=y0, x1=x1, y1=y1)
}

ss1a <- perp.segment.vert(score[,1], score[,2])
segments(x0 = ss1a$x0, x1 = ss1a$x1, y0 = ss1a$y0, y1 = ss1a$y1, col='light blue',lwd=2)

with(score,text(V2 ~ V1, labels=as.factor(rownames(score)), pos = 3))
##SECOND PART RESTORING THE DATA:



dat2 <- score
head(dat2)
X1 <- as.matrix(dat2) 
head(X1)

#Plot of two columns:


plot(V2 ~ V1, col = as.factor(rownames(dat2)), xlim=c(-2.8,2.8),ylim=c(-2.8,2.8),pch = 19,data = dat2)

abline(v=0,h=0, col = "dark gray")



abline(0, e_vectors[1,2]/e_vectors[1,1],col='red')
abline(0, e_vectors[2,1]/e_vectors[2,2],col='light blue',lwd=2)

arrows(x0 = 0, y0 = 0, x1 = lambda[1]*e_vectors[1,1], y1 = lambda[1]*e_vectors[1,2],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = lambda[2]*e_vectors[2,1], y1 = lambda[2]*e_vectors[2,2],col="blue", lwd=2)
with(dat2,text(V2 ~ V1, labels=as.factor(rownames(dat2)), pos=2))

# Rotate:

rot <- X1%*%solve(e_vectors)

rot1<- as.data.frame(rot)
colnames(rot1) <- c("Rot1","Rot2")

plot(Rot2 ~ Rot1, col = as.factor(rownames(rot1)), xlim=c(-2.8,2.8),ylim=c(-2.8,2.8),
     pch = 19,main="Data Rotation",data = rot1)

abline(v=0,h=0, col = "dark gray")


abline(0, e_vectors[1,2]/e_vectors[1,1],col='red')
abline(0, e_vectors[2,1]/e_vectors[2,2],col='light blue',lwd=2)

arrows(x0 = 0, y0 = 0, x1 = lambda[1]*e_vectors[1,1], y1 = lambda[1]*e_vectors[1,2],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = lambda[2]*e_vectors[2,1], y1 = lambda[2]*e_vectors[2,2],col="blue", lwd=2)

with(rot1,text(Rot2 ~ Rot1, labels=as.factor(rownames(rot1)), pos=3))
# Contract data

contract <- rot %*% solve(lambda_matrix)
contract_dat <- as.data.frame(contract)
colnames(contract_dat) <- c("Recons.1","Recons.2")
head(contract_dat)

plot(Recons.2 ~ Recons.1, col = as.factor(rownames(contract_dat)), xlim=c(-2.8,2.8),ylim=c(-2.8,2.8),pch = 19, main="Data Contraction", 
     xlab="Reconstructed Atomic Number", ylab="Reconstructed melting.point",data = contract_dat)

abline(v=0,h=0, col = "dark gray")

abline(0, e_vectors[1,2]/e_vectors[1,1],col='red')
abline(0, e_vectors[2,1]/e_vectors[2,2],col='light blue',lwd=2)
arrows(x0 = 0, y0 = 0, x1 = lambda[1]*e_vectors[1,1], y1 = lambda[1]*e_vectors[1,2],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = lambda[2]*e_vectors[2,1], y1 = lambda[2]*e_vectors[2,2],col="blue", lwd=2)

with(contract_dat,text(Recons.2 ~ Recons.1, labels =as.factor(rownames(contract_dat)), pos=3))

plot(melting.point ~ atomic.no, col = as.factor(rownames(scaled_dat)), xlim=c(-2.8,2.8),ylim=c(-2.8,2.8),pch = 19, main="Original Data",data = scaled_dat)

abline(v=0,h=0, col = "dark gray")



abline(0, e_vectors[1,2]/e_vectors[1,1],col='red')
abline(0, e_vectors[2,1]/e_vectors[2,2],col='light blue',lwd=2)

arrows(x0 = 0, y0 = 0, x1 = lambda[1]*e_vectors[1,1], y1 = lambda[1]*e_vectors[1,2],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = lambda[2]*e_vectors[2,1], y1 = lambda[2]*e_vectors[2,2],col="blue", lwd=2)
with(scaled_dat,text(melting.point ~ atomic.no, labels = as.factor(rownames(scaled_dat)), pos=3))

