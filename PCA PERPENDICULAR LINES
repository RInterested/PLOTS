dat<-read.csv(file.choose())
head(dat)
colnames(dat)[7] <- "lattice"
colnames(dat)[2] <- "atomic.no"
dat <- subset(dat[1:15,1:3])
head(dat)

scaled_dat <- as.data.frame(scale(dat[,2:3],center=T)) 
head(scaled_dat)
X <- as.matrix(scaled_dat) # Autoscaled matrix of A.
head(X)

scaled_dat <- cbind(dat$compounds,scaled_dat) # Reformatting original dat with autoscaled values
colnames(scaled_dat)[1] <- "compounds"
head(scaled_dat)

(dat[1,2] - mean(dat[,2]))/sd(dat[,2]) # Confirming what scaling did.

C <- cov(X) # Covariance matrix
C

lambda <- eigen(C)$values
lambda_matrix <- diag(2)*eigen(C)$values # Eigenvalues matrix
lambda_matrix

e_vectors <- eigen(C)$vectors # Eigenvectors matrix (6 x 6)
e_vectors

score_matrix <- X %*% e_vectors # Score matrix = (44 x 6) %*% (6 x 6) = (44 x 6)
head(score_matrix)

score_df <- cbind(dat[,1],as.data.frame(score_matrix))
colnames(score_df)[1] <- names(dat)[1]
head(score_df)


#relative influence of eigenvalues, for instance PC1:

eigen(C)$values[1]/sum(eigen(C)$values) * 100

par(mfrow=c(2,2))




#Plot of two columns:

plot(melting.point ~ atomic.no, col = compounds, pch = 19, data = scaled_dat)
with(scaled_dat,text(melting.point ~ atomic.no, labels = compounds, cex=0.6, pos=2))
abline(v=0,h=0, col = "dark gray")

#Overlap pertinent evectors

arrows(x0 = 0, y0 = 0, x1 = e_vectors[1,1], y1 = e_vectors[1,2],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = e_vectors[2,1], y1 = e_vectors[2,2],col="blue", lwd=2)

abline(0, e_vectors[1,2]/e_vectors[1,1],col='purple')
abline(0, e_vectors[2,1]/e_vectors[2,2],col='light blue')

#Plot the lines from first evector to points

line1 <- c(0, e_vectors[1,2]/e_vectors[1,1])

perp.segment.coord <- function(x0, y0, line1){
  
  #finds endpoint for a perpendicular segment from the point (x0,y0) to the line1
  
  a <- line1[1]  #intercept
  b <- line1[2]  #slope
  
  x1 <- (x0 + b * y0 - a * b)/(1 + b^2)
  y1 <- a + b * x1
  list(x0=x0, y0=y0, x1=x1, y1=y1)
}

ss <- perp.segment.coord(scaled_dat$atomic.no, scaled_dat$melting.point, line1)
# do.call(segments, ss)
# which is the same as:
segments(x0 = ss$x0, x1 = ss$x1, y0 = ss$y0, y1 = ss$y1, col='purple')


plot(melting.point ~ atomic.no, col = compounds, pch = 19, data = scaled_dat)
with(scaled_dat,text(melting.point ~ atomic.no, labels = compounds, cex=0.6, pos=2))
abline(v=0,h=0, col = "dark gray")

#Overlap pertinent evectors

arrows(x0 = 0, y0 = 0, x1 = e_vectors[1,1], y1 = e_vectors[1,2],col="red",lwd=2)
arrows(x0 = 0, y0 = 0, x1 = e_vectors[2,1], y1 = e_vectors[2,2],col="blue", lwd=2)

abline(0, e_vectors[1,2]/e_vectors[1,1],col='purple')
abline(0, e_vectors[2,1]/e_vectors[2,2],col='light blue')


line1a <- c(0, e_vectors[2,2]/e_vectors[2,1])
ssa <- perp.segment.coord(scaled_dat$atomic.no, scaled_dat$melting.point, line1a)
# do.call(segments, ss)
# which is the same as:
segments(x0 = ssa$x0, x1 = ssa$x1, y0 = ssa$y0, y1 = ssa$y1, col='light blue')

#Now compare side-by-side with plotted first and second column Scores

plot(score_df$V2 ~ score_df$V1, col=compounds, pch = 19, xlab='V1', ylab='V2',data=scaled_dat)
with(score_df,text(V2 ~ V1, labels=compounds,cex = 0.6, pos = 2))
abline(v=0, col = 'purple')
abline(h=0, col='light blue')


perp.segment.horiz <- function(x0, y0){
  
  #finds endpoint for a perpendicular segment from the point (x0,y0) to the horizontal
  x1 <- 0
  y1 <- y0
  list(x0=x0, y0=y0, x1=x1, y1=y1)
}

ss1 <- perp.segment.horiz(score_df$V1, score_df$V2)
segments(x0 = ss1$x0, x1 = ss1$x1, y0 = ss1$y0, y1 = ss1$y1, col='purple')

plot(score_df$V2 ~ score_df$V1, col=compounds, pch = 19, xlab='V1', ylab='V2',data=scaled_dat)
with(score_df,text(V2 ~ V1, labels=compounds,cex = 0.6, pos = 2))
abline(v=0, col = 'purple')
abline(h=0, col='light blue')


perp.segment.vert <- function(x0, y0){
  
  #finds endpoint for a perpendicular segment from the point (x0,y0) to the horizontal
  x1 <- x0
  y1 <- 0
  list(x0=x0, y0=y0, x1=x1, y1=y1)
}

ss1a <- perp.segment.vert(score_df$V1, score_df$V2)
segments(x0 = ss1a$x0, x1 = ss1a$x1, y0 = ss1a$y0, y1 = ss1a$y1, col='light blue')
